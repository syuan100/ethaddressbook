var ethAddressBook=function(){"use strict";const e=async function(e,t){const r=(new TextEncoder).encode(e),n=(new TextEncoder).encode(t),s=await crypto.subtle.digest("SHA-256",n),o=crypto.getRandomValues(new Uint8Array(12)),a={name:"AES-GCM",iv:o},c=await crypto.subtle.importKey("raw",s,a,!1,["encrypt"]);return{iv:o,encBuffer:await crypto.subtle.encrypt(a,c,r)}},t=async function(e,t,r){const n=(new TextEncoder).encode(r),s=await crypto.subtle.digest("SHA-256",n),o={name:"AES-GCM",iv:t},a=await crypto.subtle.importKey("raw",s,o,!1,["decrypt"]),c=await crypto.subtle.decrypt(o,a,e);return(new TextDecoder).decode(c)},r=function(e){return String.fromCharCode.apply(null,new Uint8Array(e))},n=function(e){const t=new ArrayBuffer(e.length);let r=new Uint8Array(t);for(var n=0,s=e.length;n<s;n++)r[n]=e.charCodeAt(n);return t},s={};var o=[{name:"store_swarm_hash",outputs:[],inputs:[{type:"bytes32",name:"inputPt1"},{type:"bytes32",name:"inputPt2"}],constant:!1,payable:!1,type:"function",gas:70682},{name:"get_swarm_hash",outputs:[{type:"bytes32[2]",name:"out"}],inputs:[{type:"address",name:"_address"}],constant:!0,payable:!1,type:"function",gas:1294},{name:"swarmHash__pt1",outputs:[{type:"bytes32",name:"out"}],inputs:[{type:"address",name:"arg0"}],constant:!0,payable:!1,type:"function",gas:787},{name:"swarmHash__pt2",outputs:[{type:"bytes32",name:"out"}],inputs:[{type:"address",name:"arg0"}],constant:!0,payable:!1,type:"function",gas:823}];const a=web3.eth.contract(o).at("0x95275693aF9E7b20F8Dbb7466Bb1652510d93359");return s.getBook=function(e,r){return fetch("http://localhost:8500/bzz:/"+e,{method:"GET"}).then(e=>e.text()).then(e=>{let s=JSON.parse(e);return!0===s.encrypted?async function(e,r){let s=JSON.parse(e);if(!0===s.encrypted){if(r){let e=new Uint8Array(s.addressBook.iv),a=n(decodeURIComponent(s.addressBook.encBuffer));try{var o=await t(a,e,r)}catch(e){return new Error("Unable to decrypt address book due to either a wrong password or a corrupted address book.")}return o}return new Error("Cannot decrypt addressbook - No password supplied for encrypted address book object.")}return s.addressBook}(e,r):s.addressBook})},s.storeBook=async function(t,n,s){if(!function(e){try{var t=JSON.parse(e)}catch(e){return console.error("Address books must be JSON.stringified() objects."),!1}return Array.isArray(t.addresses)?t.addresses.every(function(e){return"string"==typeof e.label})?!!t.addresses.every(function(e){return web3.isAddress(e.address)})||(console.error("Each address entry must be an object that contains a key named 'address' corresponding to a valid eth address."),!1):(console.error("Each address entry must be an object that contains a key named 'label' corresponding to a string."),!1):(console.error("Address books must have a key named 'addresses' corresponding to an array of address entries."),!1)}(n))throw new Error("Cannot store address book. Please see errors above.");{let o=!1;s&&(o=!0,n=await async function(t,n){let s=await e(t,n);return{iv:JSON.parse("["+s.iv.toString()+"]"),encBuffer:encodeURIComponent(r(s.encBuffer))}}(n,s));const c={encrypted:o,addressBook:n};fetch("http://localhost:8500/bzz:/",{method:"POST",body:JSON.stringify(c)}).then(e=>{if(e.ok)return e.text()}).then(e=>{const r=e.substr(0,32),n=e.substr(32);return async function(e,t,r){return new Promise((n,s)=>a.store_swarm_hash(t,r,{from:e},function(e,t){return e?s(e):t?n(t):void 0}))}(t,r,n)})}},s.getHash=async function(e){return new Promise((t,r)=>a.get_swarm_hash(e,{from:e},function(e,n){if(e)return r(e);if(n){let e=web3.toAscii(n[0])+web3.toAscii(n[1]);return t(e)}}))},s}();
