"use strict";const encryptText=async function(e,t){const r=(new TextEncoder).encode(e),s=(new TextEncoder).encode(t),a=await crypto.subtle.digest("SHA-256",s),n=crypto.getRandomValues(new Uint8Array(12)),o={name:"AES-GCM",iv:n},c=await crypto.subtle.importKey("raw",a,o,!1,["encrypt"]);return{iv:n,encBuffer:await crypto.subtle.encrypt(o,c,r)}},decryptText=async function(e,t,r){const s=(new TextEncoder).encode(r),a=await crypto.subtle.digest("SHA-256",s),n={name:"AES-GCM",iv:t},o=await crypto.subtle.importKey("raw",a,n,!1,["decrypt"]),c=await crypto.subtle.decrypt(n,o,e);return(new TextDecoder).decode(c)},ab2str=function(e){return String.fromCharCode.apply(null,new Uint8Array(e))},str2ab=function(e){const t=new ArrayBuffer(e.length);let r=new Uint8Array(t);for(var s=0,a=e.length;s<a;s++)r[s]=e.charCodeAt(s);return t},contract=function(e,t,r,s){var a;switch(e){case"web3":a=web3.eth.contract(t).at(r);break;case"ethers":switch(s){case"3":a=new ethers.Contract(r,t,ethers.getDefaultProvider("ropsten"));break;case"4":a=new ethers.Contract(r,t,ethers.getDefaultProvider("rinkeby"));break;default:a=new ethers.Contract(r,t,ethers.getDefaultProvider())}}return a},Web3=require("web3"),web3$1=new Web3("ws://localhost:8546"),eab={},swarmHashJsonInterfaceVYPER=[{name:"store_swarm_hash",outputs:[],inputs:[{type:"bytes32",name:"inputPt1"},{type:"bytes32",name:"inputPt2"}],constant:!1,payable:!1,type:"function",gas:70682},{name:"get_swarm_hash",outputs:[{type:"bytes32[2]",name:"out"}],inputs:[{type:"address",name:"_address"}],constant:!0,payable:!1,type:"function",gas:1294},{name:"swarmHash__pt1",outputs:[{type:"bytes32",name:"out"}],inputs:[{type:"address",name:"arg0"}],constant:!0,payable:!1,type:"function",gas:787},{name:"swarmHash__pt2",outputs:[{type:"bytes32",name:"out"}],inputs:[{type:"address",name:"arg0"}],constant:!0,payable:!1,type:"function",gas:823}],swarmHashAddressRopstenVYPER="0xe330529D363cBa6f1C1b7A81287026Fe93741736",swarmHashAddressRinkebySOLIDITY="0x95275693aF9E7b20F8Dbb7466Bb1652510d93359";var CURRENT_SWARM_HASH_ADDRESS,CURRENT_WEB3_API,swarmHashContractInstance,CURRENT_SWARM_HASH_INTERFACE=swarmHashJsonInterfaceVYPER;const PUBLIC_SWARM_URL="https://swarm-gateways.net/";var CURRENT_GATEWAY_URL=PUBLIC_SWARM_URL;function init(){eab.setWeb3API()}async function storeHash(e,t,r){return new Promise((s,a)=>swarmHashContractInstance.store_swarm_hash(t,r,{from:e},function(e,t){return e?a(e):t?s(t):void 0}))}async function encryptAddressBook(e,t){let r=await encryptText(e,t);return{iv:JSON.parse("["+r.iv.toString()+"]"),encBuffer:encodeURIComponent(ab2str(r.encBuffer))}}async function decryptAddressBook(e,t){let r=JSON.parse(e);if(!0===r.encrypted){if(t){let e=new Uint8Array(r.addressBook.iv),a=str2ab(decodeURIComponent(r.addressBook.encBuffer));try{var s=await decryptText(a,e,t)}catch(e){return new Error("Unable to decrypt address book due to either a wrong password or a corrupted address book.")}return s}return new Error("Cannot decrypt addressbook - No password supplied for encrypted address book object.")}return r.addressBook}function verifyAddressBook(e){try{var t=JSON.parse(e)}catch(e){return console.error("Address books must be JSON.stringified() objects."),!1}return Array.isArray(t.addresses)?t.addresses.every(function(e){return"string"==typeof e.label})?!!t.addresses.every(function(e){return web3$1.isAddress(e.address)})||(console.error("Each address entry must be an object that contains a key named 'address' corresponding to a valid eth address."),!1):(console.error("Each address entry must be an object that contains a key named 'label' corresponding to a string."),!1):(console.error("Address books must have a key named 'addresses' corresponding to an array of address entries."),!1)}eab.setWeb3API=function(e){if(e)switch(e){case"web3":"object"==typeof web3$1?CURRENT_WEB3_API="web3":console.log("Unable to set api because 'web3' is not available.");break;case"ethers":"object"==typeof ethers?CURRENT_WEB3_API="ethers":console.log("Unable to set api because 'ethers' is not available.");break;default:CURRENT_WEB3_API=null}else"object"==typeof web3$1?(CURRENT_WEB3_API="web3",console.log("Web3 api set to 'web3.js'")):"object"==typeof ethers?(CURRENT_WEB3_API="ethers",console.log("Web3 api set to 'ethers.js'")):console.log("No web3 api found. Please install metamask, web3.js, or ethers.js")},eab.setNetwork=async function(e){"3"===e?CURRENT_SWARM_HASH_ADDRESS=swarmHashAddressRopstenVYPER:"4"===e&&(CURRENT_SWARM_HASH_ADDRESS=swarmHashAddressRinkebySOLIDITY),swarmHashContractInstance=contract(CURRENT_WEB3_API,CURRENT_SWARM_HASH_INTERFACE,CURRENT_SWARM_HASH_ADDRESS,e),console.log(swarmHashContractInstance)},eab.getBook=function(e,t){return fetch(CURRENT_GATEWAY_URL+"bzz:/"+e,{method:"GET"}).then(e=>e.text()).then(e=>{let r=JSON.parse(e);return!0===r.encrypted?decryptAddressBook(e,t):r.addressBook})},eab.storeBook=async function(e,t,r){if(!verifyAddressBook(t))throw new Error("Cannot store address book. Please see errors above.");{let s=!1;r&&(s=!0,t=await encryptAddressBook(t,r));const a={encrypted:s,addressBook:t};fetch(CURRENT_GATEWAY_URL+"bzz:/",{method:"POST",body:JSON.stringify(a)}).then(e=>{if(e.ok)return e.text()}).then(t=>{const r=t.substr(0,32),s=t.substr(32);return storeHash(e,r,s)})}},eab.getHash=async function(e){return new Promise((t,r)=>swarmHashContractInstance.get_swarm_hash(e,{from:e},function(e,s){if(e)return r(e);if(s){let e=web3$1.toAscii(s[0])+web3$1.toAscii(s[1]);return t(e)}}))},init(),module.exports=eab;
